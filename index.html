<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <title>Laetitia Laversa</title>
    <link href="style.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope&family=Montserrat&display=swap" rel="stylesheet">
</head>

<body>
    <div class="banniere">
        <header><h1>Laetitia Laversa, Ph.D.</h1></header>
        <nav>
            <a class="box" href="#home"> About me </a>
            <a class="box" href="research.html"> Publications </a>
            <a class="box" href="teaching.html"> Teaching </a>
            <a class="box" href="contact.html"> Contact </a>
        </nav>
    </div>

    <h2 id=home>About me</h2>

    <img src="images\photo_gdformat.jpg" alt="Laetitia Laversa" width="125xp">
<div class="presentation">
    <p >
        <!-- I am currently a postdoctoral researcher in Micalis (INRAE Jouy-en-Josas), in the
        <a class="link-intro-extern"
            target="_blank"
            title="Team's website"
            href=https://www.micalis.fr/Poles-et-Equipes/Pole-Microbiologie-des-Systemes-et-de-Synthese/Bio-RetroSynthese-Jean-Loup-Faulon>
            Bio-RetroSynthèse team
        </a>
        where I'm working on active learning applied to synthetic biology.
        <br>
    -->
        I am currently a postdoctoral researcher at Université Sorbonne Paris Nord, LIPN (Villetaneuse) in LoVe team, affiliated to the ANR project 
        <a class="link-intro-extern" target="_blank" title="ANR BisoUS" href=https://anr-bisous.ls2n.fr> BisoUS </a>. 
        I'm working on control for timed automata with 
        <a class="link-intro-extern"
        target="_blank"
        title="André's website"
        href=https://lipn.univ-paris13.fr/~andre>
            Pr. Étienne André</a>, 
        <a class="link-intro-extern"
        target="_blank"
        title="Lefaucheux's website"
        href=https://elefauch.github.io>
            Dr. Engel Lefaucheux
        </a> and 
        <a class="link-intro-extern"
        target="_blank"
        title="Duflot's website"
        href=https://members.loria.fr/MDuflot>
            Dr. Marie Duflot-Kremer</a>. <br>
        I did a Ph.D. in Computer Science 
        on verification of distributed systems 
        in Université Côte d'Azur, under the supervision of
        <a class="link-intro-extern"
        target="_blank"
        title="Lozes's website"
        href=https://www.i3s.unice.fr/~elozes>
            Pr. Étienne Lozes
        </a>
        and
        <a class="link-intro-extern" 
        target="_blank"
        title="Di Giusto's website"
        href=https://www.i3s.unice.fr/digiusto/node/1>
            Dr. Cinzia Di Giusto
        </a>.
        <br>
        My main interests are modelling and formal methods.
        <br>
        <a title="PDF" class="link-intro-alone-intern" target="_blank" href="pdf\laversa2024.pdf">Download my CV here</a>
    </p>
</div>
    <div style="clear:both"></div>


    <h3>Ph.D. Subject</h3>
<h4> Title: Synchronizability for distributed systems </h4>
<a title="PDF" class="link-intro-intern" target="_blank" href="pdf\These_Laversa.pdf">Download my thesis here</a>
<br>
A very short explanation: <a title="Youtube link" target="_blank" class="link-intro-alone-extern" href="https://www.youtube.com/watch?v=jOjTaqzalBM">Participation to "Ma thèse en 180 secondes"</a>

<div class="phd"> 
<b>Abstract</b> <br>
<strong>Distributed systems</strong> are ubiquitous and their implementation is complex and error-prone. 
In order to check for errors, they can be modeled as systems of <strong>communicating automata</strong>, 
where each automaton represents the behavior of an element of the system. Verification 
problems such as reachability are undecidable in such a model. Indeed, a system of 
communicating automata is Turing-equivalent. For that, the use of approximations is 
necessary. <strong>k-synchronizability</strong> is one of these techniques. A system is k-synchronizable if, 
for all executions, there is an equivalent execution that can be divided into phases 
containing k messages. These phases are called k-exchanges. In this thesis, we analyse 
k-synchronizable systems: we show that reachability is decidable and we are interested 
in the membership problem, that is: given a system, decide whether it is k-synchronizable. 
We study both the case where k is an input of the problem, and the case where we have to 
guess a k such that the system is k-synchronizable. We study them according to the <strong>type 
of communication</strong> of the system. Either the system is in mailbox and so each process 
has only one buffer to store all received messages, or the system is in peer-to-peer, 
and each process has a buffer for each sender. Both problems are decidable when the system 
is communicating in mailbox. When the system is communicating in peer-to-peer, the first one 
is decidable and the second remains open. Finally, we point out some counter-intuitive cases 
of k-synchronizable systems that lead us to propose some variations to the definition of 
k-synchronizability. A comparative study of the state-of-art classes of systems and our new 
classes concludes our work.
<!-- 
    Most of the <strong>distributed systems</strong> we use nowadays are based on the
message-passing paradigm where systems are structured into parties that
interact only by sending/receiving messages. Message-passing programming is
largely employed in high performance computing (MPI, OpenMP, etc), event-driven
applications built on top of actor-based languages (Scala, Erlang,etc),
service-oriented architectures, peer-to-peer applications, etc. Unfortunately,
because of the variety of <strong>communication models</strong> (peer to peer, mailbox, etc.), of
the ambiguities of the specifications of the communication primitives, and of
the difficulty of running representative tests, etc., it is error prone and
therefore often reserved to experts. The majority of the issues above stem from
the asynchronous nature of messages exchange. Indeed, the conception and the
analysis of message-passing programs is greatly simplified if one can assume
that all communications occur synchronously, i.e., that each message is received
exactly at the same time it has been sent. As a matter of fact, some properties
(e.g., reachability) becomes decidable if the underlying communication model is
synchronous. We are thus interested in understanding under which conditions we
could avoid using asynchronous models and being able to design and prove correct
simpler but equally powerful systems. This is a property that goes under the
name of <strong>synchronizability</strong>. Synchronizability of a distributed system is the
property that the observable behaviour of the system is the same whether or not
the communications are synchronous. The main topic of my Ph.D. is to develop
methods and tools that help designing safe distributed systems based on the
notion of synchronizability.
-->
</div> 


<div class="pied-de-page"></div>
</body>

</html>